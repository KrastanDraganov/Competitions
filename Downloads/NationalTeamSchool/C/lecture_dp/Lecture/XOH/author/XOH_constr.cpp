#include<iostream>
#include<cstring>
using namespace std;
long Count=0;
void proc(long long N,long M)
{Count=((Count==M-1)?0:Count+1);
}
static void make(char state,long long N,long M,long long k)
{if (k==N){proc(N,M);return;}
 switch(state)
 {case 0://празна дума или само 'O'-та: може да се солепи всичко
  {make(0,N,M,k+1);//долепяме 'O', състоянието не се променя
   make(1,N,M,k+1);//долепяме 'X' -> състояние 1
   make(2,N,M,k+1);//долепяме 'H' -> състояние 2
   break;
  }
  case 1://тук вече има 'X'
  {make(1,N,M,k+1);//долепяме 'X', не се променя състоянието
   make(3,N,M,k+1);//долепяме 'H', вече има 'X' и 'H' -> състояние 3
   make(4,N,M,k+1);//долепяме 'O' сега има 'X' и 'О' -> състояние 4
   break;
  }
  case 2://тук вече има 'H'
  {make(2,N,M,k+1);//долепяме 'H', не се променя състоянието
   make(3,N,M,k+1);//долепяме 'X', вече има 'H' и 'X' -> състояние 3
   make(5,N,M,k+1);//долепяме 'O', сега има 'H' и 'О' -> състояние 5
   break;
  }
  case 3://тук вече съдържа и 'X', и 'H', все едно в какъв ред
  {make(3,N,M,k+1);//долепяме 'H', състоянието не се променя
   make(3,N,M,k+1);//долепяме 'X', състоянието не се променя
   make(6,N,M,k+1);//долепяме 'O', вече има и 'X', и 'H', след които 'O' -> състояние 6
   break;
  }
  case 4://тук вече има 'X', а надясно от него 'O'
  {make(4,N,M,k+1);//долепяме 'X', състоянието не се променя
   make(4,N,M,k+1);//долепяме 'O', състоянието не се променя
   //вече не може да се долепя 'H'
   break;
  }
  case 5://тук вече има 'H', а надясно от него 'O'
  {make(5,N,M,k+1);//долепяме 'H', състоянието не се променя
   make(5,N,M,k+1);//долепяме 'O', състоянието не се променя
   //вече не може да се долепя 'X'
   break;
  }
  case 6://тук вече има и 'X', и 'H', а надясно от тях 'O'
  {make(6,N,M,k+1);//долепяме 'O', състоянието не се променя
   //вече не може да се долепя нито 'H', нито 'X'
  }
 };
}
int main()
{long long N;
 long M;
 cin>>N>>M;
 make(0,N,M,0);
 cout<<Count<<endl;
 return 0;
}
