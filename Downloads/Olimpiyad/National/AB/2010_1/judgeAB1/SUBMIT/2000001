// dynamic programming approach #1.1

#include <cstdio>
#include <iostream>
#include <vector>
#include <string.h>

const int MAXN = 1024;
const int INF = 2000000000;
const bool dbg = 0;

int N,T,D,S;
int F[MAXN];

std::vector<int> adj[MAXN],children[MAXN];
int length[MAXN][MAXN];

void readInput()
{
    scanf("%d%d%d%d",&N,&T,&D,&S);
    for (int i = 0; i < N; i++)
     scanf("%d",F+i);
    memset(length,-1,sizeof(length));
    for (int i = 0; i < N - 1; i++)
    {
        int a,b,c;
        scanf("%d%d%d",&a,&b,&c);
        a--; b--;
        adj[a].push_back(b);
        adj[b].push_back(a);
        length[a][b] = length[b][a] = c;
    }
}

int parent[MAXN];
std::vector<int> subtree[MAXN];
bool isInSubtree[MAXN][MAXN];

void hangTree(int v)
{
    for (int i = 0; i < adj[v].size(); i++)
    {
        int child = adj[v][i];
        if (child == parent[v])
            continue;
        children[v].push_back(child);
        parent[child] = v;
        hangTree(child);
    }
    int curDist = 0;
    for (int ancestor = v; ancestor > -1 && curDist <= D; ancestor = parent[ancestor])
    {
        subtree[ancestor].push_back(v);
        isInSubtree[ancestor][v] = 1;
        curDist += parent[ancestor] == -1 ? 0 : length[ancestor][parent[ancestor]];
    }
}

int dist[MAXN][MAXN];

void calcDists()
{
    memset(dist,127,sizeof(dist));
    int q[MAXN];
    for (int v = 0; v < N; v++)
     {
            dist[v][v] = 0;
            q[0] = v;
            for (int st=0,en=1; st<en; st++)
             {
                    int u = q[st];
                    for (int i = 0; i < adj[u].size(); i++)
                     {
                            int w = adj[u][i];
                            if ( dist[v][w] < INF ) continue;
                            dist[v][w] = dist[v][u] + length[u][w];
                            if (dist[v][w] <= D)
                                q[en++] = w;
                     }
             }
     }
}



int dp[MAXN];
int pathdp[MAXN][MAXN];
int subdp[MAXN][MAXN];
int solveDp(int v);
int solvePathdp(int, int);
int solveSubdp(int, int);


int solveDp(int v)
{
    int &answer = dp[v];
    if (answer > -1)
        return answer;
        
    answer = 0;
    for (int i = 0; i < children[v].size(); i++)
    {
        int w = children[v][i];
        answer += solveDp(w);
    }
    
    for (int i = 0; i < subtree[v].size(); i++)
    {
        int c = subtree[v][i];
        if (answer < solvePathdp(v, c) - S)
            answer = solvePathdp(v, c) - S;
    }
    
    return answer;
}

int solvePathdp(int v, int c)
{
    int &answer = pathdp[v][c];
    if (answer > -1)
        return answer;
        
    answer = F[v] * T;
    for (int i = 0; i < children[v].size(); i++)
    {
        int u = children[v][i];
        if (isInSubtree[u][c])
        {
            answer += solvePathdp(u, c);
        }
        else
        {
            int w = u;
            answer += solveSubdp(w, c);
        }
    }
    
    return answer;
}

int solveSubdp(int b, int c)
{
    int &answer = subdp[b][c];
    if (answer > -1)
        return answer;

    answer = 0;
    if (dist[b][c] <= D)
    {
        answer = F[b] * T;
        for (int i = 0; i < children[b].size(); i++)
        {
            int w = children[b][i];
            answer += solveSubdp(w, c);
        }
    }
    
    if (answer < solveDp(b))
        answer = solveDp(b);

    return answer;
}

int main()
{
    readInput();
    parent[0] = -1;
    hangTree(0);
    calcDists();
    
    memset(dp,-1,sizeof(dp));
    memset(pathdp,-1,sizeof(pathdp));
    memset(subdp,-1,sizeof(subdp));

    printf("%d\n", solveDp(0));
    fprintf(stderr, "time: %.5lf\n", (double)clock()/CLOCKS_PER_SEC);
    return 0;
}


